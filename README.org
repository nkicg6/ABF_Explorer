#+OPTIONS: toc:nil author:nil title:nil date:nil num:nil ^:{} \n:1 todo:nil
#+PROPERTY: header-args :eval never-export

* ABF_Explorer
A simple [[https://riverbankcomputing.com/software/pyqt/download5][PyQt5]] and [[https://pyqtgraph.readthedocs.io/en/latest/][pyqtgraph]] based GUI to view, annotate, and perform semi-automated analysis on Axon Binary Format (=ABF=) files.

#+CAPTION: ABF_Explorer UI
#+ATTR_HTML: :width 50% :height 50% :alt  :title  :align 
#+ATTR_LATEX: :placement [H] :width 0.5\textwidth
[[file:docs/img/abfexplorer-example.png]]

We use the excellent pyABF package (https://github.com/swharden/pyABF) to do the hard work of parsing ABF files, Thanks [[https://github.com/swharden/][Scott!]]

The idea of ABF_Explorer is to provide a *simple*, cross platform (shar-able) app for quickly viewing ABF files without a bunch of python/matlab/etc. boilerplate. Often I want to quickly look through some files or show an example, but I don't know exactly which file or sweep it is. This tool allows me to quickly scroll through files, read the metadata, and take a look at the data. 
** Useage

   Currently in development. clone this repository, make a virtual environment, =pip install -r requirements.txt= and run =python abf_explorer= from the project root. If you want to load a directory of abf's at startup, use the =-d= or =--startup-dir= flag and pass the path to the directory. 

** Note and past efforts
This project is under active development and is not well tested!
I attempted this before using Tkinter and matplotlib ([[https://github.com/nkicg6/tkABF_Explorer][tkABF_Explorer]]) with the goal of simplify packaging and deployment (Tkinter ships with python, so less native C and C++ dependencies that may require compilation). Building GUIs (well) is difficult, and I found that the type of plot interaction that I wanted was difficult (for me) to achieve with Tkinter and matplotlib with reasonable performance, so I started fresh using PyQt and pyqtgraph's bindings to the powerful Qt framework. 
* Roadmap/plans
** ABF_Explorer should be easy to both *share* and *use*
- =pip= installable, with few dependencies and reasonable command line options.
- Easy to share and use with non-programmers or people unfamiliar with the nightmare that is python packaging.
  - This means making a simple downloadable =app= or =exe=, likely with [[https://www.pyinstaller.org/][PyInstaller]], [[https://beeware.org/][BeeWare]], or a comparable tool.
  - Cross platform (Windows, Mac OS, and Linux)
- Keep it simple!
** ABF_Explorer may offer limited semi-automated analysis features
- I will use ABF_Explorer for analysis, but this is not the primary purpose of the version that I will distribute.
- semi-automated analysis features will be add-hoc and likely only used via the =pip= version.

* Development and design decisions
** testing 
We use [[https://docs.pytest.org/en/latest/][pytest]]. Run unit test by running =pytest= from the base directory.
** naming conventions
- =vars= should start with =var_*=
- follow the python convention of private vars and functions (functions/vars that will not be called or accessed by the controller) should start with =_=
- Qt widgets like buttons, listboxes, labels (=PyQt5.QWidget.*=), etc. should start with what the thing is, followed by an underscore and a more descriptive name. (=button_select_abfs=)
- Divide the classes into =#VARS=, =widgets=, =layout=, and =Actions=. 

** layout and class structure
The main class, =ABFExplorer= has a simple grid layout, and is responsible for instantiating the classes for the other widgets and placing them in the grid. The other classes will typically contain one widget (inheriting from QWidget) and will have their own layout management. These individual widgets may have simple or more complex layouts, and I may decided to change the layout managers or contents over time. By keeping the main class layout simple, and any complexities in the other widget classes, I can delegate all the complex layout decisions to individual widget classes as needed, and have a working app even if I do major changes within individual widgets. 

A good example of this is the =FileInfoPlotControls= class. It contains a parent class (=QWidget=), and two distinct layouts, a =QVBoxLayout=, and a =QFormLayout=. These two layouts are arranged in the parent =QWidget= in a grid, but this could easily change later. As far as the main window in ABFExplorer knows (or cares), it is just placing the main =FileInfoPlotControls= =QWidget=. 

** class interactions and inheritance

Inheritance confuses me, so beyond inheriting from Qt classes, I will not be using multiple inheritance. 
I am trying to reduce coupling by passing only data between classes. I am currently refactoring so classes communicate exclusively with Qt signals/slots, passing pure data. Signals will be connected to slots from the main class upon startup. 

*In this system, if a class directly accesses (or mutates) a field in another class, that is a bug* (I know there are several 'bugs' now, I'm working on it). All information will pass as regular data structures returned from functions or class methods.

For example, the plotting functions are in the =plotting.PlotWidget= class. The main =update_plot()= method accepts a =dictionary= with a set of keys for =x=, =y=, and =name=. =update_plot()= does not grab something from another class or even know about another class, it simply accepts a =dict=, which could come from /anywhere/. This makes testing easier, reduces coupling, and makes it easier to adapt to new future data input methods and options in the future if I want. 

** Useful docs and links (Best docs are pyside)
- https://pyside.github.io/docs/pyside/PySide/QtGui/QGridLayout.html#PySide.QtGui.PySide.QtGui.QGridLayout.setColumnMinimumWidth
- https://doc.qt.io/qtforpython/overviews/qtwidgets-tutorials-addressbook-part2-example.html
  
** development
Set environmental variable =DEBUG_DIR= to pass for quicker startup (no need to choose a directory) so startup like this:
=python abf_explorer --startup-dir $DEBUG_DIR=
* Development TODO's
- auto re-scale between plotting sessions (after clear it won't always re-scale when plotting again)
- abf_explorer will contain ONLY visualization tools. Experimental analysis stuff will be developed in =abf_analysis=
- +add logging.+
- Add a message for error display. This should be mirror the log and be displayed as a dropdown text area if wanted/needed to send to me if there are problems so I have some context.
- When mouse over, show name of trace.
- adopt model view controller architecture (=mvc= branch)
  - possibly use a global =context= object to store all state (from emitted signals), as described in "[[https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201][A Philosophy of Software Design]]"




